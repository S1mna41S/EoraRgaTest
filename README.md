EORA RAG (FastAPI + FAISS + GigaChat)

Минимальный RAG-сервис, который отвечает на вопросы по материалам кейсов eora.ru

# ======================================================================================================================

Быстрый старт

# 1) Установка
python -m venv .venv
# Windows:
.venv\Scripts\activate
# Linux/macOS:
source .venv/bin/activate

pip install -r requirements.txt

# 2) Конфиг
cp .env.example .env
# В .env заполнить GIGACHAT_CREDENTIALS (см. ниже)

# 3) Индексация ссылок из data/links.txt
python -m rag.ingest

# 4) Запуск API
uvicorn api.main:app --reload
# Документация: http://127.0.0.1:8000/docs

# 5) Проба запроса
curl -X POST http://127.0.0.1:8000/ask -H "Content-Type: application/json" -d "{\"question\":\"Что вы можете сделать для ритейлеров?\"}"


Ответ вернёт текст и список URL-источников. В самом тексте модель может ставить сноски вида [1].


# ======================================================================================================================

Что тут внутри

FastAPI для HTTP.
FAISS (CPU) для векторного поиска.
GigaChat как чат-модель и (по возможности) эмбеддинги.
LangChain — чтобы не писать всё вручную.
Загрузка и парсинг: httpx, trafilatura + fallback beautifulsoup4.
Фолбэк эмбеддингов: sentence-transformers (если GigaChat embeddings не доступны).
Python 3.10+ (у меня на 3.12 работает).

# ======================================================================================================================

Структура

eora-rag/
  api/           # FastAPI endpoint /ask
  app/           # конфиг и утилиты
  rag/           # индексация и ответ (RAG)
  data/          # links.txt, сырые HTML и индекс FAISS
  .env.example
  requirements.txt
  README.md

data/links.txt — список ссылок из ТЗ (можно дополнять другими страницами eora.ru).
data/raw/ — сохранённые HTML для отладки.
data/index/ — FAISS + метаданные после индексации.

# ======================================================================================================================

Конфиг (.env)

Репозиторий содержит только .env.example. Реальный .env не коммитим.

# Authorization Key: base64(client_id:client_secret)
GIGACHAT_CREDENTIALS=base64_clientId_colon_clientSecret_here
GIGACHAT_SCOPE=GIGACHAT_API_PERS   # или GIGACHAT_API_CORP, что выдали
GIGACHAT_VERIFY_SSL=true           # для dev можно временно false при SSL-проблемах

# Опционально (обычно не нужны):
# GIGACHAT_ACCESS_TOKEN=           # bearer (~30 мин). Если пусто — SDK сам получит по credentials.
# GIGACHAT_BASE_URL=
# GIGACHAT_AUTH_URL=

Если у вас есть только client_id/client_secret, сгенерируйте значение для GIGACHAT_CREDENTIALS:

import base64
base64.b64encode(f"{client_id}:{client_secret}".encode()).decode()

# ======================================================================================================================

Как это работает (коротко)

Индексация (rag/ingest.py)
тянем страницы из data/links.txt, кладём сырые HTML в data/raw/;
чистим текст trafilatura → если не получилось, bs4.get_text() как fallback;
режем на чанки (≈1200 символов, overlap 200);
эмбеддинги через GigaChatEmbeddings или (если не взлетело) sentence-transformers;
сохраняем FAISS в data/index/.
Ответ (rag/answer.py)
берём top-K релевантных чанков из индекса;
формируем промпт с перечисленными источниками [n];
зовём GigaChat, возвращаем ответ + список URL.

# ======================================================================================================================

API
POST /ask

Request
{
  "question": "Что вы можете сделать для ритейлеров?",
  "k": 6
}

Response
{
  "answer": "Краткий ответ... [1] ... [2]\n\nИсточники: [1] https://eora.ru/..., [2] https://eora.ru/...",
  "sources": [
    "https://eora.ru/cases/...",
    "https://eora.ru/cases/..."
  ]
}

k — сколько фрагментов подтягивать из индекса (по умолчанию 6).

# ======================================================================================================================

Частые проблемы

SSL: self-signed certificate in certificate chain
Корпоративный прокси/сертификат. На время разработки можно:

GIGACHAT_VERIFY_SSL=false


Лучше поставить доверенный корневой сертификат в систему и Python. Где лежит certifi:

python -c "import certifi; print(certifi.where())"


Дальше добавьте PEM вашего корня в этот файл или укажите переменные:

SSL_CERT_FILE=.../bundle.pem
REQUESTS_CA_BUNDLE=.../bundle.pem


И верните GIGACHAT_VERIFY_SSL=true.

401/403 при получении токена
Проверьте GIGACHAT_CREDENTIALS (это именно base64(client_id:client_secret)) и GIGACHAT_SCOPE.

Эмбеддинги падают
Скрипт индексации сам переключится на sentence-transformers, чтобы не падать.

# ======================================================================================================================

Что пробовал сделать / как проверял

Собрал простой RAG без фронта: индексация ссылок из ТЗ → FAISS → GigaChat-ответ с источниками.

Прогонял вопросы вручную (в том числе «что можете для ритейлеров?»), проверял, чтобы в ответе были ссылки на реальные страницы.

Что работает
Индексация, поиск, ответы со списком источников. Fallback эмбеддингов спасает, если GigaChat недоступен.

Что не очень
Пока нет фронтенда и кэша ответов. Жёсткой проверки [n] внутри текста тоже нет (только список в конце).

Если было бы больше времени

небольшой web-виджет с подсветкой источников;

кэширование /ask (по нормализованному вопросу + версии индекса);

«строгие» цитаты — автопроверка, что все [n] в тексте валидны;

инкрементальная индексация всего домена (sitemap, очереди);

тесты.

# ======================================================================================================================

Безопасность

.env в гит не кладём. Только .env.example.

Ключи — через переменные окружения/секреты CI.

Для продакшена SSL-проверку не отключать.

# ======================================================================================================================

Шпаргалка команд

python -m rag.ingest
uvicorn api.main:app --reload
curl -X POST http://127.0.0.1:8000/ask -H "Content-Type: application/json" -d "{\"question\":\"Что вы можете сделать для ритейлеров?\"}"


